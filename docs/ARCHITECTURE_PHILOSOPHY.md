# 具備可追溯性的資料清洗架構 (Data Cleaning with Traceability)

> **本專案的重點不在於「正確地」清洗資料。**  
> **重點在於「安全地」清洗資料。**

---

## 為什麼需要這個專案？

在真實世界的系統中，資料清洗往往沒有唯一的「正確答案」。

公司名稱、使用者輸入、地址和自由文字欄位通常具有以下特性：
- **歧義性 (Ambiguous)**
- **依賴情境 (Context-dependent)**
- **定義隨時間與對象而異**

當資料量增長到人工無法逐一驗證時，傳統的清洗方法（字串取代、原地覆蓋）會帶來極高的風險：

> **資料不會憑空消失 —— 它只是變得無法追蹤 (Untraceable)。**

本專案提出了一種「設計優先」的資料清洗方法，將 **可追溯性 (Traceability)、可逆性 (Reversibility) 與安全性 (Safety)** 視為首要考量。

---

## 真正的問題

大多數資料清洗的失敗，並非源於錯誤的規則。
而是源於 **關聯性的喪失 (Loss of relationships)**。

常見的失敗模式：

- 原始值被覆蓋 (Overwritten)
- 多個實體合併卻未留紀錄
- 無法解釋或回溯清洗決策

這些失敗導致了所謂的 **「孤兒資料」 (Orphan Data)**：

> 這些資料仍然存在，但沒人知道它從哪裡來、為什麼變成現在這樣子，或是該如何修正它。

本專案將「預防孤兒資料」視為最高指導原則。

---

## 設計原則

### 1. 原始資料不可變 (Raw Data Is Immutable)

原始輸入資料絕不允許被覆蓋。

- 原始值必須被無限期保存
- 所有清洗結果都僅視為「衍生狀態」
- 系統必須隨時能重建原始輸入

> 如果原始資料丟失了，未來將沒有任何修正的機會。

---

### 2. 清洗即對應，而非取代 (Cleaning Is Mapping, Not Replacement)

資料清洗不是單純的字串操作。

它是一個 **關係指派問題 (Relationship Assignment Problem)**。

我們不採用：
```
原始值 → 清洗後的值 (覆蓋)
```

我們採用：
```
原始值 → 對應關係 (Mapping) → 標準化實體
```

「對應關係」本身即是資料，而不只是副作用。

這使得我們能夠處理：
- 一對多關係
- 多對一關係
- 在不丟失資料的情況下重新指派

---

### 3. 延遲不可逆的決策 (Postpone Irreversible Decisions)

當無法自信地做出決定時，**不要強行決定**。

- 相似的值可以暫時保持分離
- 多個候選結果可以共存
- 最終的合併可以延後執行

不可逆的操作（例如合併實體）必須是：
- 顯式的 (Explicit)
- 可審計的 (Auditable)
- 可逆的 (Reversible)

---

## 必要的資料結構

每一筆清洗後的紀錄，都應由以下最小元件組成：

### 1. 原始識別碼 (Raw Identifier)
原始的輸入值。
- 永不修改
- 永不刪除

### 2. 穩定的內部 ID (Stable Internal ID)
即使名稱或顯示方式改變，ID 也不會改變。
- 主要參考鍵 (Primary Key)
- 防止身份漂移 (Identity Drift)

### 3. 標準化數值 (Normalized Value)
當前清洗或標準化後的呈現方式。
- 被視為一種 **視圖 (View)**，而非真相來源
- 可能隨時間改變

### 4. 對應 ID (Mapping ID)
代表原始輸入與標準化實體之間的關係。
- 原始 (Raw) → 標準化 (Normalized)
- 可以被重新指派
- 支援多重對應

### 5. 決策元資料 (Decision Metadata)
記錄 *為什麼* 這個對應關係存在。
範例：
- 規則式標準化 (Rule-based)
- 人工指派 (Manual assignment)
- 系統建議 (System suggestion)

### 6. 時間戳記 / 版本控制 (Timestamp / Versioning)
每個決策都必須包含時間維度。
- 支援回滾 (Rollback)
- 支援審計 (Audit)
- 支援版本比較

---

## 資料生命週期

本設計中的典型生命週期：

```
原始輸入 (Raw Input)
   ↓
候選生成 (Candidate Generation)
   ↓
對應指派 (Mapping Assignment)
   ↓
清洗視圖 (Cleaned View)
   ↓
(可選) 合併 / 重新指派 (Merge / Reassignment)
```

關鍵特性：
> **沒有任何步驟是最終且不可逆的。**

---

## 失敗模式與防禦機制

### 失敗：覆蓋原始資料
**防禦：** 原始資料是不可變的。

### 失敗：過早合併
**防禦：** 合併是延遲且顯式的。

### 失敗：「為什麼資料會變成這樣？」
**防禦：** 每個對應關係都保留了決策元資料。

---

## 範圍與非目標

### 本專案「不」做什麼：
- 定義單一正確的命名標準
- 保證語意上的絕對正確
- 取代領域專家的知識

### 本專案「做」什麼：
- 防止資料遺失
- 防止孤兒資料
- 支援未來的修正
- 支援會隨時間演進的定義

---

## 心智模型 (Mental Model)

與其問：
> 「這個值是正確的嗎？」

不如問：
> 「我能解釋這個值是怎麼來的嗎？—— 另外，我能安全地修改它嗎？」

如果答案是肯定的，系統就是在正常運作。

---

## 何時使用此模式

此設計適用於：
- 資料量大到無法進行全面人工驗證
- 命名沒有絕對的真相標準
- 定義會隨時間改變
- 長期維護性至關重要

---

## 結語

乾淨的資料是暫時的。

**可追溯的資料才能在變動中存活。**
